const Default = {
    "lineWidth": 2,
    "strokeStyle": "#222222",
    "lineCap": "butt",
    "lineJoin": "mitter",
    "backgroundColor": null
};

const sigpadMap = new Map();

// finished param: only draw last point after points wont differ from exec to exec
function drawPoints(ctx, points) {
    // draw a point instead
    if (points.length == 1) {
        var b = points[0];
        ctx.beginPath(), ctx.arc(b.x, b.y, ctx.lineWidth / 2, 0, Math.PI * 2, !0), ctx.closePath(), ctx.fill();
        return
    }

    // draw line for just two points
    if (points.length == 2) {
        ctx.beginPath(), ctx.moveTo(points[0].x, points[0].y);
        ctx.lineTo(points[1].x, points[1].y);
        ctx.stroke();
        return
    }

    ctx.beginPath(), ctx.moveTo(points[0].x, points[0].y);
    // draw a bunch of quadratics, using the average of two points as the control point
    var i;
    for (i = 1; i < points.length - 2; i++) {
        var c = (points[i].x + points[i + 1].x) / 2,
            d = (points[i].y + points[i + 1].y) / 2;
        ctx.quadraticCurveTo(points[i].x, points[i].y, c, d);
    }
    if (i < points.length - 1)
        ctx.quadraticCurveTo(points[i].x, points[i].y, points[i + 1].x, points[i + 1].y);
    //ctx.closePath();
    ctx.stroke();
}
export default class Sigpad {


    static getOrCreateInstance(element, config) {
        return this.getInstance(element.id) || new this(element, typeof config === 'object' ? config : null)
    }

    static getInstance(id) {
        var pads = [...sigpadMap].filter(([k, v]) => k.id == id)
        if (pads.length > 0) {
            return pads[0][1];
        }
        return null;
    }

    static getAllInstances() {
        var instances = [];
        sigpadMap.forEach((value, key, map) => {
            instances.push(value);
        });
        return instances;
    }

    constructor(element, options) {
        if (!sigpadMap.has(element)) {
            sigpadMap.set(element, this);
        }

        this._config = this._getConfig(options);
        this._element = element;
        this._newImage = false;
        this._newBgImage = false;
        this._currentStroke = [];
        this._drawing = false;

        this._setListeners();
        this._applyOptions();

        this._element.width = this._element.clientWidth;
        this._element.height = this._element.clientHeight;
    }

    destroy() {
        if (!sigpadMap.has(this._element)) {
            return
        }

        sigpadMap.delete(this._element);

        this._element.removeEventListener("mousedown", this._onStart);
        this._element.removeEventListener("mouseup", this._onEnd);
        this._element.removeEventListener("mousemove", this._onMove);

        this._element.removeEventListener("touchstart", this._onStart);
        this._element.removeEventListener("touchend", this._onEnd);
        this._element.removeEventListener("touchmove", this._onMove);
    }

    _applyOptions(ctx = null) {
        if (ctx == null) {
            ctx = this._element.getContext("2d");
        }
        ctx.strokeStyle = this._config.strokeStyle;
        ctx.fillStyle = this._config.strokeStyle;
        ctx.lineWidth = this._config.lineWidth;
        ctx.lineCap = this._config.lineCap;
        ctx.lineJoin = this._config.lineJoin;
    }

    _getRelativeMousePos(e) {
        var r = this._element.getBoundingClientRect();

        var x = e.clientX;
        var y = e.clientY;

        var startX = r.left;
        var startY = r.top;
        var w = r.right - r.left;
        var h = r.bottom - r.top;

        return {
            x: x - startX,
            y: y - startY
        };
    }

    clear() {
        this._currentStroke = [];
        this._img = undefined;
        this.render(true);

        this._drawing = false;
    }

    getImage() {
        return this._element.toDataURL();
    }

    setImage(image) {
        if (this._config.backgroundColor != null && this._config.backgroundColor != "") {
            ctx.fillStyle = this._config.backgroundColor;
            ctx.fillRect(0, 0, this._element.width, this._element.height);
        }

        if (this._config.backgroundImage != null && this._config.backgroundImage != "") {
            this.setBackgroundImage(this._config.backgroundImage);
        }
        var t = this;
        var img = new Image();
        img.onload = function () {
            t._img = img;
            t._newImage = true;
        };
        img.src = image;

    }

    setBackgroundImage(image) {
        if (this._bgImg == undefined) {
            var t = this;
            this._bgImg = new Image();
            this._bgImg.onload = function () { t._newBgImage = true };
            this._bgImg.src = image;
        }
    }

    _getConfig(config) {
        return {
            ...Default,
            ...config,
            ...(typeof config === 'object' && config ? config : {})
        }
    }


    _setListeners() {
        var instance = this;
        this._element.addEventListener("mousedown", this._onStart);
        document.addEventListener("mouseup", function (mouseEvent) { instance._onEnd(instance, mouseEvent); }, { capture: true });
        document.addEventListener("mousemove", function (mouseEvent) { instance._onMove(instance, mouseEvent); }, { capture: true });

        this._element.addEventListener("touchstart", this._onStart);
        document.addEventListener("touchend", function (mouseEvent) { instance._onEnd(instance, mouseEvent); }, { capture: true });
        document.addEventListener("touchmove", function (mouseEvent) { instance._onMove(instance, mouseEvent); }, { capture: true });
    }

    _onStart(mouseEvent) {
        mouseEvent.preventDefault();
        if ("touches" in mouseEvent) {
            mouseEvent = mouseEvent.touches[0];
        }

        var data = Sigpad.getInstance(this.id);

        if (data._element.classList.contains('disabled')) {
            return;
        }

        var mousePos = data._getRelativeMousePos(mouseEvent);
        if (mousePos != null) {
            data._currentStroke.push(mousePos);
            data._drawing = true;

            const event = new CustomEvent('sigpad.start', { detail: data.getImage() });
            data._element.dispatchEvent(event);
        }
    }

    _onEnd(sender, mouseEvent) {
        if (!this._drawing) return;

        mouseEvent.preventDefault();
        if ("touches" in mouseEvent) {
            mouseEvent = mouseEvent.touches[0];
        }

        var data = Sigpad.getInstance(sender._element.id);
        if (data._element.classList.contains('disabled')) {
            return;
        }

        data._drawing = false;
        data.render(true);
        data._currentStroke = [];

        const event = new CustomEvent('sigpad.finish', { detail: data.getImage() });
        data._element.dispatchEvent(event);

    }

    _onMove(sender, mouseEvent) {
        if (!this._drawing) return;
        //mouseEvent.preventDefault();
        if ("touches" in mouseEvent) {
            mouseEvent = mouseEvent.touches[0];
        }

        var data = Sigpad.getInstance(sender._element.id);

        if (data._element.classList.contains('disabled')) {
            return;
        }

        if (data._drawing) {
            var pos = data._getRelativeMousePos(mouseEvent);
            if (pos != null) {
                data._currentStroke.push(pos);
                const event = new CustomEvent('sigpad.move', {});
                data._element.dispatchEvent(event);
            } else { 
                data._onEnd(mouseEvent);
            }
        }
    }

    //finished: signal to renderer that all individual mouse position arrays are complete
    render(force) {
        if (this._element.width != this._element.clientWidth) {
            this._element.width = this._element.clientWidth;
        }

        if (this._drawing || this._newBgImage || this._newImage || force) {
            this._newBgImage = false;
            this._newImage = false;
            var stroke = this._currentStroke;

            var ctx = this._element.getContext("2d");
            this._applyOptions(ctx);

            ctx.clearRect(0, 0, this._element.width, this._element.height);

            if (this._bgImg != undefined && this._bgImg.complete) {
                ctx.drawImage(this._bgImg, 0, 0,
                    this._bgImg.width * window.devicePixelRatio,
                    this._bgImg.height * window.devicePixelRatio,
                    0, 0,
                    this._bgImg.width * window.devicePixelRatio,
                    this._bgImg.height * window.devicePixelRatio
                );
            }

            if (this._img != undefined && this._img) {
                ctx.drawImage(this._img, 0, 0);
            }

            if (stroke.length > 0) {
                drawPoints(ctx, stroke);
            }
        }
    }
}

const requestAnimFrame = (function (callback) {
    return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimaitonFrame ||
        function (callback) {
            window.setTimeout(callback, 1000 / 144);
        };
})();

(function renderSignatures() {
    requestAnimFrame(renderSignatures);
    Sigpad.getAllInstances().forEach((sigpad, index) => {
        sigpad.render(false);
    });

})();
